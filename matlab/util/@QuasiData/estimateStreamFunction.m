

function estimateStreamFunction(this)
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5555
        % estimateNearStreamfunction(this)
        %
        % Calculates the coefficients b1, b2, c1, c2, for the Quasi-2D analytical
        % stream function -- the approximation for the 2D flow generated by a
        % swimmer in confinement.
        %
        % INPUTS:
        %   - VelData               A VelocityData object with data generated from
        %                           Ludwig.
        %
        % OUTPUTS:
        %   - B                     Coefficients for the analytical approximation,
        %                           where b1 = B(1), b2 = B(2), c1 = B(3), c2 =
        %                           B(4);
        
        
        % Check VelData has been correctly initialised
        validateattributes(this.VelData, {'VelocityData'}, {});
        this.VelData.checkForPolarPlane;
        
        % Fetch coordinate data
        X = this.VelData.X(:);
        Y = this.VelData.Y(:);
        R = this.VelData.R(:);
        Th = this.VelData.Th(:);
        
        % Fetch velocity data
        Vr = this.VelData.velocityPlanePolar(:, :, 1);
        Vt = this.VelData.velocityPlanePolar(:, :, 2);
        Vr = Vr(:);
        Vt = Vt(:);
        
        % Fetch parameters
        x0 = this.VelData.x0;
        y0 = this.VelData.y0;
        this.lambda = sqrt(this.VelData.systemSize(3)^2/12);
        
        
        % 
        % Generate list of points to exclude
        a = this.VelData.colloid_a;
        U = this.VelData.colloidVel(:, 11);
        U = sqrt(dot(U, U));

        this.colloidRadius = a;
        this.colloidVelocity = U;

        [Xc, Yc] = generateRadialXYPoints(x0, y0, a + 3);
        
        % Generate idx list of points
        idxList = [];
        for i = 1:length(Xc)
            for j = 1:length(X)
        
                if(Xc(i) == X(j) && Yc(i) == Y(j))
                    idxList = [idxList, j];
                    break;
                end
            end
        end
        
        % Delete colloid points
        X(idxList) = [];
        Y(idxList) = [];
        Vr(idxList) = [];
        Vt(idxList) = [];
        R(idxList) = [];
        Th(idxList) = [];
        
        % Run fminsearch
        this.B_far  = fminsearch(@Q2D_farfield, [-0.1, -0.1, 0.1, 0.1]);
        this.B_near = fminsearch(@Q2D_nearfield, [this.B_far(1), this.B_far(2)]);
        
        
        %%%%%%%%%%%%%%%%%% ANALYTICALLY DEFINED STREAM FUNCTIONS %%%%%%%%%%%%%%%%%%
            
        function f = Q2D_farfield(B)
            % INPUT PARAMETERS
            %   b1, b2, c1, c2          - Unknown constants to be solved for
            %   x0, y0                  - Swimmer/colloid center
            %   lambda                  - 'Screening length' parameter, should be set
            %                               to sqrt(h^2/2)
            %   x, y                    - Cartesian coordinates to be solved at
            
            % Introduce polar coordinates
            
            
            f = 0;
            
            for idx = 1:length(X)
            
                r = R(idx);
                theta = Th(idx);
            
                % Define radial component
                ur = B(1).*r.^-2.*cos(theta) + 2*B(2).*r.^-3.*cos(2*theta) + ... 
                        B(3)./r.*besselk(1, r./this.lambda).*cos(theta) + 2.*B(4)./r.*besselk(2, r./this.lambda).*cos(2*theta);
                
                % Define angular component
                ut = B(1).*r.^-2.*sin(theta) + B(2).*r.^-3.*sin(2*theta) + ... 
                        B(3)./r.*(besselk(0, r./this.lambda) + r./this.lambda.*besselk(1, r./this.lambda)).*sin(theta) + ...
                        B(4)./r.*(besselk(1, r./this.lambda) + 2*r./this.lambda.*besselk(2, r./this.lambda)).*sin(2*theta);
            
                f = f + (Vr(idx) - ur).^2 + (Vt(idx) - ut).^2;
            end
        end
    
        function f = Q2D_nearfield(B)
            % INPUT PARAMETERS
            %   b1, b2, c1, c2          - Unknown constants to be solved for
            %   x0, y0                  - Swimmer/colloid center
            %   lambda                  - 'Screening length' parameter, should be set
            %                               to sqrt(h^2/2)
            %   x, y                    - Cartesian coordinates to be solved at
            
            % Introduce polar coordinates
            
            
            f = 0;
            kappa1 = besselk(1, a./this.lambda);
            kappa2 = besselk(2, a./this.lambda);
            
            for idx = 1:length(X)
            
                r = R(idx);
                theta = Th(idx);
                
                Kt1 = besselk(1, r./this.lambda)./kappa1;
                Kt2 = besselk(2, r./this.lambda)./kappa2;
    
                Kd1 = -1./(this.lambda*kappa1).*(besselk(0, r./this.lambda) + r./this.lambda.*besselk(1, r./this.lambda));
                Kd2 = -1./(this.lambda*kappa2).*(besselk(1, r./this.lambda) + 2.*r./this.lambda.*besselk(2, r./this.lambda));
                
                % Define radial component
                ur = r.^-1.*B(1).*cos(theta).*(r^-1 - a.^-1.*Kt1) + r.^-1.*U.*a.*cos(theta).*Kt1 + ...
                        2.*B(2).*cos(2.*theta).*(r^-2 - a.^-2.*Kt2);
    
                % Define angular component
                ut = B(1).*sin(theta).*(-r^-2 - a.^-1.*Kd1) + U.*a.*sin(theta).*Kd1 + ...
                        B(2).*sin(2.*theta).*(-2.*r^-3 - a.^-2.*Kd2);
            
                f = f + (Vr(idx) - ur).^2 + (Vt(idx) - ut).^2;
            end
        end
end